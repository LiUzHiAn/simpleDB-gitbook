# 第21章—索引及包`simpledb.index`

当我们写下某条SQL语句时，我们可能只对某张表（或某几张表）中的某些特定的记录感兴趣，即那些满足了select谓词逻辑的记录。索引（`index`）存在的目的就是为了允许数据库系统无需遍历搜索整个表记录文件就可以定位到某些特定的记录。在本章中，我们将考虑3种不同的索引实现方式：静态hash索引、可扩展hash索引、以及B-tree（注意，不是叫B减树，就是B树），基于索引带来的优点，随后我们将实现关系代数操作中的`select`和`join`操作。

## 21.1 索引的接口

在第6章中，我们介绍了索引的基本原则，可以归纳为如下：

- 一个索引其实就是一个文件，这个文件中按照一定规则对某个表中的某个（或多个字段）进行了记录；
- 每条索引记录对应一条数据记录；
- 每条索引记录包含了被索引字段的取值，以及这条数据记录的标识符（或者是`rid`）。

当数据库系统想要获取到被索引字段指定取值的那些数据记录时，数据库系统可以通过查看索引，从而得到这些具体的数据记录的标识符，从而快速地在数据记录文件中移动，这将大大地提高查询效率，因为我们可以避免对整个表记录进行遍历。

在本章中，我们将考虑一个数据库系统是如何实现并且实用索引的。在SimpleDB中，我们对索引进行了简化（但这完全不影响功能），即一个索引只能索引一个字段，也就是说，在一条索记录中，只包含2个字段（被索引的字段、以及`rId`）,我们不妨称这两个字段为`dataval`和`datarid`。

> SimpleDB中的每条索引记录包含一个`dataval`字段和一个`datarid`字段：
>
> - `dataval`字段记录的说被索引字段的具体取值；
> - `datarid`字段记录的说对应数据记录的标识符，即`rid`。

在SimpleDB中，一个索引就是一个实现了`Index`接口的对象，`Index`接口如下所示：

```java
public interface Index {
    public void beforeFirst(Constant searchKey) throws IOException;
    public boolean next() throws IOException;
    public RID getDataRid();
    public void insert(Constant dataval,RID datarid) throws IOException;
    public void delete(Constant dataval,RID datarid) throws IOException;
    public void close();
}
```

`Index`接口的大部分方法都和`RecortFile`中的类似，客户端可以在索引文件中的任何位置移动，可以检索到当前位置处的索引记录，也可以插入或者删除索引记录。然而，因为索引都是按照某些明确的方式进行使用，所以`Index`接口中的一些方法相对来说更加明确。

一个SimpleDB的客户端在搜索索引时，总是会提供一个值（我们称这个值为搜索健），并且检索得到那些匹配`dataval`的索引记录。方法`beforeFirst()`正好需要这个搜索键作为参数。后续不断调用`next()`方法，将不断移动索引文件中的“指针”，直到下一条匹配`dataval`的索引记录，如果不存在下一条匹配的索引记录的话，那就返回false。

索引不需要诸如`getInt()`或`getString()`这样的方法，因为所有的索引记录都只含有两个相同的字段，此外，客户端也从不需要检索得到索引记录的`dataval`字段，因为这个字段本身就是客户端给定的参数！因此，唯一需要的检索方法就是`getDataRid()`了，这个方法会返回当前索引记录的`datarid`。

下面的代码片段展示了一个使用索引的例子，代码的功能是搜索所有专业id为10的学生，并且打印出这些学生的姓名。注意，代码使用了一个table scan来检索学生记录，虽然说这个table并不会真正被“scan“；相反，代码调用了table scan对象的`moveToRid()`方法来定位到指定的数据记录处。

```java
SimpleDB.init("studentDB");
Transaction tx = new Transaction();

// open a scan to table
Plan stuPlan = new TablePlan("student", tx);
TableScan stuScan = (TableScan) stuPlan.open();

// open the index on majorid
MetadataMgr mdMgr = SimpleDB.metadataMgr();
Map<String, IndexInfo> indexes = mdMgr.getIndexInfo("student", tx);
IndexInfo ii = indexes.get("majorid");
Index idx = ii.open();

// retrieve all index records which have a dataval of 10
idx.beforeFirst(new IntConstant(10));
while (idx.next()) {
  // use the datarid to go to the corresponding record in table STUDENT
  RID dataRid = idx.getDataRid();
  stuScan.moveToRId(dataRid);
  System.out.println(stuScan.getString("sname"));
}

// close the idx, the table scan, and the transaction
idx.close();
stuScan.close();
tx.commit();
```

索引除了可以查询以外，同样也可以更新或删除。下面的代码片段演示了数据库系统如何处理表的更新，代码主要完成了两个工作：

- 第一个工作就是插入了一条新的数据记录到STUDENT表中；
- 第二个工作则是从STUDENT表中删除一条记录。

注意，在插入新的数据记录的同时，也必须对应插入一条（如果某张表有n个索引，那么是n条）索引记录；当然，删除数据记录的同时也必须删除对应的索引记录。首先，代码会用一个字典获取到STUDENT表的所有索引；在后续每次对索引进行某项操作的过程中，代码都会遍历这个字典。

```java
// suppose the STUDENT(sname varchar(5), majorid int) table already exists
SimpleDB.init("studentDB");
Transaction tx = new Transaction();

// create a table STUDENT(sname, majorid) and a index on STUDENT(majorid)
Planner planner = SimpleDB.planner();
String str = "create table student (sname varchar(5), majorid int)";
planner.executeUpdate(str, tx);
String createIndexStr = "create index stuMajorIdIndex on student(majorid)";
planner.executeUpdate(createIndexStr, tx);

// open a scan to table
Plan stuPlan = new TablePlan("student", tx);
TableScan stuScan = (TableScan) stuPlan.open();

// open the index on MajorId
MetadataMgr mdMgr = SimpleDB.metadataMgr();
Map<String, IndexInfo> indexInfos = mdMgr.getIndexInfo("student", tx);
Map<String, Index> indexes = new HashMap<>();
for (String fldName : indexInfos.keySet()) {
  Index idx = indexInfos.get(fldName).open();
  indexes.put(fldName, idx);
}

// Task 1: insert a two STUDENT record
// insert the data record first
stuScan.insert();
stuScan.setString("sname", "Sam");
stuScan.setInt("majorid", 10);
// then insert a corresponding index record
RID datarid = stuScan.getRID();
for (String fldName : indexes.keySet()) {
  Constant dataval = stuScan.getVal(fldName);
  Index idx = indexes.get(fldName);
  idx.insert(dataval, datarid);
}

// insert the data record first
stuScan.insert();
stuScan.setString("sname", "Andy");
stuScan.setInt("majorid", 10);
// then insert a corresponding index record
for (String fldName : indexes.keySet()) {
  Constant dataval = stuScan.getVal(fldName);
  Index idx = indexes.get(fldName);
  idx.insert(dataval, stuScan.getRID());
}

// Task 2: find and delete Sam's record
stuScan.beforeFirst();
while (stuScan.next()) {
  if (stuScan.getString("sname").equals("Sam")) {
    // delete the corresponding index record(s) first
    RID rid = stuScan.getRID();
    for (String idxFldName : indexes.keySet()) {
      Constant dataval = stuScan.getVal(idxFldName);
      Index idx = indexes.get(idxFldName);
      idx.delete(dataval, rid);
    }

    // then delete the data record
    stuScan.delete();
    break; // todo why break here???
  }
}

// close the resources
stuScan.close();
for (Index idx : indexes.values()) {
  idx.close();
}
tx.commit();
```

上述的两个测试代码实际上根本不知道索引是怎么实现的，唯一的需求就是知道`Index`接口。本章的后续部分将按下述安排展开：

- 21.2—21.4小节将展示3种不同的索引实现——其中前两种基于hash实现，第三种则是基于排序树实现；
- 21.5—21.6小节将考虑数据库中的查询处理器和planner组件如何利用索引使得查询更高效。

## 21.2 静态hash索引

我们从静态hash索引开始讨论起，这应该是实现索引的最简单的方式之一。虽然说这种方式不是最高效的策略，但是它相对来说更好理解并且将相关的概念揭示得更加清晰，因此从静态哈希索引介绍起比较合理。

### 21.2.1 静态hash

静态哈希索引使用一个固定大小为N的容器，容器中的每个元素我们称之为桶（`bucket`），从0到N-1计数。静态哈希索引同样拥有一个哈希函数，这个函数可以将任意一个值（也就是dataval）映射到某个桶中，而对应的索引记录则被放置在这个桶中。虽然说拥有索引记录之间不同的datavals可能会被映射到同一个桶中，但哈希函数总是尽可能地将索引记录相对均匀地分布在各个桶中。

> 静态hash索引将索引记录存放在桶中；拥有相同hash值的索引记录会被存放在同一个桶中。

一个静态hash索引如下工作：

- 为了存储一条索引记录，需要先根据这条索引记录的dataval得到对应的hash值，再将这条索引记录放在对应的桶中；
- 为了找到某条索引记录，我们先得到serach key的hash值，再从对应的桶中查找索引记录；
- 为了删除某条索引记录，我们先找到这条索引记录（按照规则2），再从这个桶中删除这条索引记录。

查找一个静态hash索引的代价与桶的数量N息息相关。如果一个索引有B个块及N个桶，那么每个桶将大概有B/N个块的长度，因此查找一个桶大概需要B/N次块访问（如果不用索引的话就需要B次块访问）。

举例来说，假设我们有一个STUDENT表中关于`sname`的索引，且桶的大小N=3，并且假设hash函数的计算方式为，对于一个字符串s，其对应的hash值为s中排在字母m前的所有字母数量模N（比方说，s=“andy”，排在字母m之前的字母有a、d两个，那么andy对应的hash值为2(mod)3=2）,并假设1个块中刚好可以存放下3条索引记录。图21-4演示了这样的3个索引桶中的情况，在图中，我们用$r_i$来表示第i条学生数据记录的rid。

![](ch21/21-4.png)

假设现在我们想要得到所有名叫`sue`的学生的datarid。

- 首先，我们根据上述的hash函数规则，得知`sue`对应的hash值为1（即被放在第1个桶中）；
- 随后，我们需要对第1个桶进行搜索，这需要花费2个块访问。

再假设我们想要得到名叫`ron`的学生的datarid，和上述过程类似，先得到hash值为0，搜索第1个桶只需要1个块访问，最终发现不存在名为`ron`的索引记录，也即不存在名为`ron`的数据记录。

图21-4的这个例子，我们都假设块的大小和桶的数量都很少，这在实际的数据库中不可能是这样的，桶的数量为1024是一个比较合乎实际的取值，这意味着索引记录会相对均匀地分布在1024个桶中，也就意味着：

- 一个大小为1024块的索引文件，大致可以在1个块访问内，搜索到指定的索引记录；
- 一个大小为2048块的索引文件，大致可以在2个块访问内，搜索到指定的索引记录；
- 以此类推...

为了对上述的值有个大致的概念，我们注意到，`SName`表的一条索引记录需要22个字节，假设是纯ascii码，则`varchar(10)`需要14个字节，而`datarid`部分需要8个字节（块号+块上的记录号）。再加上，如果我们用1个字节来表示索引记录的EMPTY / INUSE标记的话，那么1个大小为4K的块内可以存放178条索引记录（4096/23=178），于是1个包含2048个块的索引（约为8MB大小的文件）可以存放356K条索引记录，在2个块访问就可以完成对所有数据记录的搜索！（比原来的1/1000倍的访问时间还要短）

### 21.2.2 实现静态hash

在SimpleDB中，静态hash算法的实现包含在累`HashIndex`中，其代码如下：

```java
public class HashIndex implements Index {
    private static final int NUM_BUCKETS = 100;
    private Constant searchKey;
    private String idxName;  // 索引名
    private Schema schema;   // 索引表对应的schema信息
    private Transaction tx;
    private TableScan tableScan;   // 每个桶对应的tableScan对象

    public HashIndex(String idxName, Schema schema, Transaction tx) {
        this.idxName = idxName;
        this.schema = schema;
        this.tx = tx;
    }

    @Override
    public void beforeFirst(Constant searchKey) throws IOException {
        close();  // 如果有的话，先关闭之前的桶
        this.searchKey = searchKey;
        int bucket = searchKey.hashCode() % NUM_BUCKETS;  // 简单的求模作为hash函数
        String specificBucketTableName = idxName + bucket;
        TableInfo tableInfo = new TableInfo(specificBucketTableName, schema);
        tableScan = new TableScan(tableInfo, tx);
    }

    @Override
    public boolean next() throws IOException {
        while (tableScan.next()) {
            if (tableScan.getVal("dataval").equals(searchKey))
                return true;
        }
        return false;
    }

    @Override
    public RID getDataRid() {
        // 当前索引记录对应的数据记录的RID
        int blockNum = tableScan.getInt("block");
        int recordId = tableScan.getInt("id");
        return new RID(blockNum, recordId);
    }

    @Override
    public void insert(Constant dataval, RID datarid) throws IOException {
        beforeFirst(dataval);
        tableScan.insert();  // 找到索引桶文件的插入位置
        // 填写索引记录中的dataval 和 datarid 部分取值
        tableScan.setVal("dataval", dataval);
        tableScan.setInt("block", datarid.blockNumber());
        tableScan.setInt("id", datarid.id());

    }

    @Override
    public void delete(Constant dataval, RID datarid) throws IOException {
        beforeFirst(dataval);
        while (next()) {
            if (getDataRid().equals(datarid)) {
                tableScan.delete();
                return;
            }
        }
    }

    @Override
    public void close() {
        if (tableScan != null) {
            tableScan.close();
        }
    }

     /**
     * @description: 返回遍历索引的搜索代价
     * @param num_blocks: 索引的总块数
     * @param rbp: 一个块中可以存放多少条索引记录
     * @return: int
     * @author: liuzhian
     * @date: 2020/9/9
     */
    public static int searchCost(int num_blocks,int rbp) {
        return num_blocks / NUM_BUCKETS;
    }
}
```

在上述的实现中，我们将每个桶都保存在一个独立的表中，该表的名词为索引名+桶号，例如，索引`SID_INDEX`的第35个桶对应的表名为`SID_INDEX35`。方法`beforeFirst()`会首先根据searchKey得到对应的hash值，并且打开对应的桶文件。方法`next()`会从当前打开的桶文件的当前位置开始遍历，直到遇到dataval部分为searchKey的索引记录，如果遍历完还没找到满足条件的索引记录，则返回false。其中，每条索引记录的`datarid`字段由2个整型字段组成，即`block`和`id`，表示的是该索引记录对应的数据记录所处在哪个块，以及该块的第几个记录。方法`getDataRid()`会将上述两个整型数包转，返回一个`RID`类型的对象。`Insert()`和`delete()`和普通的`TableScan`中的插入和删除没有什么不同。

除了实现`Index`接口中的方法除外，我们也实现了一个静态方法`searchCost()`，这个方法会被`IndexInfo.blocksAccessed()`调用。在`IndexInfo.blocksAccessed()`方法中，会传递 2个参数给`searchCost()`方法，分别是索引的总块数，以及每个索引块可以存放多少条索引记录（即rbp，record per block）。虽然说，在静态hash的实现中，我们并不需要rbp这个参数，可是客户端可不知道我们是怎么实现索引的，所以这个参数仍需给定。

## 21.3 扩展hash索引

