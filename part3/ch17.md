# 第17章 查询处理和包`simpledb.query`

译者注：这一章中有些名词不是很好翻译，例如scan，对于这些不好翻译的词，将直接采用英文。

在前面的两章中，我没已经看到了表中的记录是怎么用记录文件来实现的，也知道了表的元数据是怎么被组织起来的，从而方便以后的记录访问。接下来的三章，我没将会考虑一下数据库系统怎么支持对表的查询。

第4章中介绍了两种查询语言：`关系代数(relational algebra)`和`SQL`。关系代数相对来说比较容易实现，因为每个操作都是一个很小的、且定义好的小任务，然而SQL比较难直接去实现，因为一个SQL查询可以嵌入许多的任务和逻辑。事实上，我们在第4章中已经看到了，一个SQL查询语句可以被表达成一个关系代数查询树，这种对应关系提供了实现SQL的关键—数据库系统首先将SQL查询转换为关系代数，然后执行关系代数查询树。

在这章中，我们将研究一下关于如何执行关系代数的问题，而后续的两章将研究如何将SQL翻译成关系代数。

## 17.1 Scan
一个`Scan`就是代表一个关系代数查询的对象，`Scan`在SimpleDB中是通过接口`Scan`来实现的，接口`Scan`的方法和`RecordFile`类中的方法很相似，客户端可以遍历一个scan，移动到下一条记录，并且检索相应的字段的值。代码如下：
```Java

public interface Scan {
    // 移动到第一条记录之前
    public void beforeFirst();

    // 移动到下一条记录，如果没有下一条记录，返回false
    public boolean next();

    // 关闭scan，如果有subScan，也会相应关闭
    public void close();

    // 获取当前记录指定字段的值，被抽象成了一个Constant对象
    public Constant getVal(String fieldName);

    // 获取当前字段指定int字段的值
    public int getInt(String fieldName);

    // 获取当前字段指定string字段的值
    public String getString(String fieldName);

    // 判断是否有指定字段
    public boolean hasField(String fieldName);

}
```
下面的代码演示了如何使用一个scan，方法`printNameAndGradYear()`会遍历输入的scan，打印出每条记录的字段`sname`和`gradyear`取值。因为`Scan`是一个借口，这个方法其实并不知道这个scan是怎么构造的或者说这个scan代表的具体是哪种查询，凡是输出包含学生名字和毕业年份的查询，其实都是可以成功执行的。
```Java
public static void printNameAndGradyear(Scan s) {
    while (s.next()) {
    String sname = s.getString("sname");
    String gradyr = s.getInt("gradyear");
    System.out.println(sname + "\t" + gradyr);
    }
    s.close();
}
```

`Scan`接口和`RecordFile`类主要在下面的3个方面有所不同：
- `RecordFile`类中包含读/写的方法，而`Scan`中的方法只支持读，只有Update Scan才有写方法，我们将在17.2小节中讨论。
- `RecordFile`类需要知道表的schema信息(`RecordFile`类的构造函数需要提供一个`TableInfo`对象)，但是在`Scan`中不需要。相反，在`Scan`中有一个`hasField()`方法来判断指定的字段是否被包含在scan的输出中。
- `Scan`中除了`getInt()`和`getString()`之外还包含一个`getVal()`方法，其返回的是一个`Constant`类型的对象(详情见17.7小节)，这个类型是对int和string的抽象，这个方法的目的就是允许查询处理器在无需知道具体类型，就可以对字段的值进行比较。

每个Scan对象对应一个查询树中的一个节点，对于每一种关系代数中的操作，都对应有一个具体的Scan接口实现类，而对于查询树中的叶子节点，必定是对一个表的scan，下面的代码中展示了SimpleDB中支持的4种不同的Scan以及它们的构造函数：
```Java
public SelectScan(Scan s, Predicate pred);
public ProjectScan(Scan s, Collection<String> fldlist);
public ProductScan(Scan s1, Scan s2);
public TableScan(TableInfo ti, Transaction tx);
```
考虑一下`SelectScan`类的构造函数，它接受两个输入，一个Scan对象和一个谓词对象。Scan对象表示的是输入给select运算的表。回想一下，关系运算的输入可以是任何表或查询的结果，这刚好用一个类型为Scan的对象来表示。 由于`Scan`是一个接口，因此，无论具体是一个实际存储的表还是其他查询的结果，SelectScan对象可以对输入的表做同样的操作。

第二个谓词对象是一个`Predicate`类型的对象，我们将在17.7小节中讨论SimpleDB是怎么实现select运算中的select谓词的，在那之前，我们对谓词的讨论都会比较含糊，不过你可以暂时理解成一个高层次的抽象的概念，即对scan的结果进行比较筛选。

> 一个查询树可以用许多Scan对象来表示，树上的每个节点代表一个Scan对象。

图17-4和图17-5给出了两个示例，演示了查询树是怎么用scan对象组织起来的。

