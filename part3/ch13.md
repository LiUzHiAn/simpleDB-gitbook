# 第13章 内存管理及包`simpledb.log`和`simpledb.buffer`的实现

在本章中我们将学习数据库中的两个组件:`日志管理器（log manager）`和`缓存管理器（buffer manager）`,它们各自负责特定的文件：日志管理器负责日志文件，而缓冲管理器负责用户的数据文件。


这两个组件面临的关键问题就是，如何高效地管理驻留在内存中的磁盘块内容，并对它们进行读写。一个数据库中的内容通常要比主存的大小大得多，因此组件可能需要将这些数据内容在磁盘和内存之间来回穿梭。我们将会学习到日志管理器和缓存管理器的多种内存管理算法。日志管理器管理日志文件采用的是一种简单的，最优的算法；然而缓存管理器采用的算法只能是一种最近似估计的策略。

## 13.1 数据库内存管理的两大原则
正如我们所看到的，数据库的数据是存储在磁盘块中的。为了获取到想要的块，数据库系统需要将其中的内容读入到内存页中。数据库系统将数据在内存和磁盘之间移动时，会遵循以下两个重要的原则.
> 内存管理的两个基本原则是：
1. 最小化磁盘访问次数
2. 不要依赖于`虚存（virtual memory）`，虚存是操作系统中的概念。

***原则1：最小化磁盘访问次数***

考虑这样一个应用，它从磁盘中读入数据，然后在数据上做搜索，再执行一系列的计算并作出一些改变，最后将数据写回磁盘。我们怎样可以估计这些操作的执行用耗时？回想一下，RAM读写的速度大概比闪存块1000倍，比磁盘大约快10万倍，这意味着在绝大多数的实际场景下，将数据从磁盘读/写入内存的用间最少会比在RAM中处理块的用间多。因此，数据库系统可以做的事情就是最小化磁盘访问次数。

最小化磁盘访问次数的一个办法是避免重复的磁盘访问，这种问题在多种计算场合都会出现，且差不多有一个标准的解决方案——那就是`缓存(caching)`。举例来说，CPU中有一个局部的硬件缓存单元用来缓存一些先前执行过的指令；假设下一条将要执行的指令在cache中，那么CPU不会从RAM中把这条指令load进来，而是从cache中直接获取到（译者注：CPU的执行速度和RAM的执行速度又差了好几个数量级，所以在CPU内部会存在cache，现在的CPU也包含多级cache）。再举一个例子，一个浏览器也会将之前访问过的web页面缓存起来，下次用户请求相同的页面时（例如，点击回退上一个页面的按钮），浏览器会从缓存中得到网页内容而避免了再次通过网络检索内容。

数据系统会将磁盘块中的内容缓存在内存也中，它会跟踪哪些页包含了哪些块中的内容；通过这种方法，通过使用以及存在的内存页，就有可能可以满足客户端的请求，却避免了磁盘读写。类似地，数据库系统也只会在必要的时候将页中的内容写回到磁盘，希望可以通过单次的磁盘写入对页面的多次更改进行保存。

最小化磁盘访问非常重要以至于遍布在数据库系统的整个工作流程中。举例来说，数据库系统中选择的数据检索算法是特别选择的，因为数据库系统想要最小化磁盘访问。当一条SQL语句有多种可能的检索策略时，`planner`会选择那个需要最少磁盘访问次数的策略。

***原则2：不要依赖于虚存***

现代操作系统支持`虚存(virtual memory)`,操作系统会给每个进程一个错觉，即它拥有大量的内存来存储其代码和数据。一个进程可以在其虚拟内存空间中任意分配对象；OS会负责将每个虚拟页面映射到实际的物理内存页面。

OS支持的虚存空间通常来说都远远大于一个计算机的物理内存空间。因为不一定实际的物理内存空间能放得下当前所有的虚存页，所以OS必须将一些虚存页暂时放到磁盘中。当一个进程访问一个不在主存中的虚存页时，一次`页换入换出（page swap）`会被执行：具体来说，OS会选择一个物理页面，将该物理页面中的内容写入到磁盘中（如果有必要的话），然后将磁盘上对应的该虚存页的内容读入物理页中。

数据库系统管理磁盘块的最直接的办法就是给每个块一个它自己的页，例如，数据库系统可以为每个文件维护一个页数组，并为文件的每个块维护一个`插槽（slot）`，这些页数组可能很大，但它们都是被放在虚存中的。当数据库系统需要相应的页时，OS的虚存管理机制会按照需求，在磁盘和内存中进行换入换出，这是一个很简单，且很容易实现的策略，不幸的是，这种策略有一个严重的问题：现在控制什么时候将页写回到磁盘的是OS，而不是数据库系统，这会引发两个危险的问题：

- 第一个问题是操作系统的页面交换可能会损害数据库系统在系统崩溃后恢复的能力。 正如我们将在第14章中看到的那样，原因是被修改的页会有一个相关的日志记录，这些日志记录*必须*被在页被保存之前写回到磁盘（否则，在数据库系统崩溃后想要恢复时，就会找不到日志记录）。因为OS不知道这是日志，它可能将修改后的页换出而没有写写日志记录，因此破坏了恢复机制。
- 第二个问题是，OS不知道哪些页正在被使用，哪些页数据库系统根本不在意。OS可以作出有根据的猜测，例如LRU（Latest Recent Used）置换算法，但是假如OS猜错了，它可能会将一些再次需要的页换出，从而带来了两次不必要的磁盘访问。另一方面，一个数据库系统，对哪些页需要使用，有一个更明智的猜测。

因此，数据库系统必须管理它自己的页。通过分配相对少的可以完全装进物理内存的页，数据库系统就可以很好地管理页；这些页被称为数据库的`缓冲池（buffer pool）`。数据库系统会跟踪哪些页可以被换入换出。当一个块需要被读入页中时，数据库系统（而不是OS）会从缓存池在选择一个合适的页，如果有必要（译者注：什么是有必要？就是当页中的内容被修改了后），然后将该页中的内容（以及相应的日志记录）保存到磁盘，只有当这些工作完成了以后，才会将指定的块中的内容读到页中。（你可以看作是完成了一次数据库系统级别的swap）。

## 13.2 管理日志信息
无论什么时候用户对数据库系统进行修改时，数据库系统必须对这些更改进行跟踪，以防需要对这些操作进行撤回。描述一次修改的值被保存在一条`日志记录（log record）`中，而日志记录又被保存在`日志文件（log file）`中，新的日志记录总是被追加在日志文件的末尾。
> 日志管理器正是数据库系统中负责将日志记录写到日志文件中的那个部分。

日志管理器不知道日志记录中的内容——那是由`恢复管理器(recovery manager)`负责的部分（参见第14章）。相反，日志管理器将日志视为一个只会增加的日志记录序列。

在本节中，我们将会学习日志管理器在将日志记录写到日志文件时是怎样管理内存的。文明将最开始考虑下述的算法，这是将日志记录追加到日志中的最直接的办法。
```
1. 在内存中分配页。

2. 将日志文件的最后一块读入该页中。

3.     
    a)如果有页中有空间剩余，则将当前的日志记录追加到已有的所有日志记录之后，并将该页写回到磁盘中。
    b)如果页中没有空间剩余，则分配一个新的空页，将当前日志记录放到这个新分配的页中，并将将该页的追加到日志文件的最后一个块的后面。
```
该算法每追加一条日志记录，需要一次磁盘读操作和一次磁盘写操作。这是非常简单的策略，但不是那么高效。

图13-2示例了日志管理器在上述3a过程中的执行流程。日志文件包含3个块，总共包含8条日志记录，用$$r_1$$到$$r_8$$进行了标识。每天日志记录可以有不同的大小，在block 0中包含4条日志记录，但在block 1中只装下了3条日志记录，block 2中则还没满，只包含了1条日志记录。内存页中对应的是block 2中的内容，除了$$r_8$$以外，内存页中还将一条新的日志记录$$r_9$$放在了该页中。

![](ch13/13-2.png)

现在假设日志管理器将内存页写回到文件的block 2中，从而完成以上算法。当日志管理器最终请求添加一条新的日志记录到日志文件时，它会执行步骤1和步骤2并且将block 2 读入到内存页中。但是，请注意，这个磁盘读操作是不必要的，因为当前的日志页已经包含了日志文件block 2中的内容！（译者注：请思考下为什么？因为日志页是专门为日志管理器开辟的一系列内存页，而我们当前日志页中的内容肯定是上一次保存日志记录到文件后的样子啊！又没有人规定说，将日志页中的内容写回到日志文件后，必须把内存页中的内容也清空一遍，对吧？）因此，步骤1和步骤2都是不必要的，日志管理器只需要永久分配一个内存也，来保留上一次日志块中的内容即可。这样的结果是，所有的文件读操作全部都不再需要了，真的是妙~

其实，文件写操作也是有可能减少次数的，在上述的算法中，文件管理器在每次添加一条新的日志记录时，都会将日志页中的内容写回到磁盘，再看下图13-2，我们可以发现其实并不必要在$$r_9$$被添加时立马将日志页写回到磁盘。只要日志页中还有空间剩余，每条新的日志记录可以被很简单地被加入到页中；当页满了的时候，日志管理器可以将页写回到磁盘中，然后再清除日志页中的内容，准备下一次开始添加新的日志记录。这个新的算法，对于日志文件中的每个块会相应进行一次磁盘写操作，而不是之前的每条日志记录，这明显更优。

我们的新算法有一个小问题：由于日志管理器无法控制的情况，可能需要在日志页满之前将日志页写入磁盘。问题在于，在相关联的日志记录被写入磁盘之前，缓冲区管理器不能将已修改的数据页写入磁盘（回想一下，这是为了可以恢复系统到时候可以恢复数据）。如果这些日志记录之一恰好位于日志页中但尚未持久化到磁盘上，则无论页面是否已满，日志管理器都必须将其页面写入磁盘。（译者注：你可以考虑这就类似于通常文件操作中的`flush()`，不过好像也不完全是这个样子，反正就是提前进行磁盘写操作。）

上述讨论产生了以下新的算法执行流程：
```
1. 分配一块永久的内存页来维持日志文件中最后一个块中的日志信息，把这个页称为$$P$$.

2. 当有一个新的日志记录到来时：
    a)如果$$P$$中没有空间剩余，则将P写入磁盘并清空P中的内容。
    b)将新的日志记录添加到$$P$$中。

3. 当数据库系统请求一个特殊的日志记录写操作时：
    a)确定该记录是否驻留在$$P$$中。
    b)如果在，将$$P$$写回磁盘。
```
换句话说，有2种原因导致内存页写回到磁盘：
- 日志记录强制被写回到磁盘
- 当日志页满了

因此，一个内存也可能被写回到同一个日志块中多次，但是因为文件写操作不可能被完全地避免，我们可以认为当前的这个算法是最优的。

## 13.3 SimpleDB的日志管理器

在本节中，我们将学习SimpleDB数据库系统的日志管理器。第13.3.1节介绍了日志管理器的API，这些API包括了将日志记录追加到日志文件的方法，以及读取日志文件中记录的方法。然后13.3.2小节显示了如何用Java来实现这个日志管理器。

### 13.3.1 日志管理器的API
SimpleDB日志管理器的实现在包`simpledb.log`中，这个包有两个类：`LogMgr`类和`BasicLogRecord`类；他们的API如下代码所示。
```Java
// LogMgr.java
public class LogMgr {
    public LogMgr(String logfile);

    public int append(Object[] rec);

    public void flush(int lsn);

    public Iterator<BasicLogRecord> iterator();

}

// BasicLogRecord.java
public class BasicLogRecord {

    public BasicLogRecord(Page logPage, int pos);

    public int nextInt();

    public String nextString();
}
```