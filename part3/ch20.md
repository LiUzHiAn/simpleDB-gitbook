# 第20章 数据库服务器和包`simpledb.remote`

在本章中，我们将会研究一下客户端程序访问数据库系统的两种不同的方式：
- 数据库系统可以被嵌入在客户端中；
- 可以作为一个服务端独立运行，并接受客户端的请求。

嵌入式的数据库策略不需要再写太多的新的代码，但是应用能力有限（译者注： 可以试想一下，如果真的是这种嵌在一起的策略，为什么要当初要写并发的代码呢？）；然而，基于C/S架构的策略允许多个用户并发地共享数据库，但是这样就要求开发者去实现数据库服务端的代码，并且处理JDBC请求。我们接下来将会看到如何用Java 的RMI来构建一个数据库服务端，并且实现一个JDBC driver。

## 20.1 服务型数据库 VS 嵌入型数据库
一个应用程序访问数据库的方式有两种：
- 简介访问数据库，通过服务端；
- 直接访问数据库。

本书的第2部分主要关注的正是上述第一种方式。这种思路是说，应用程序首先调用drive中的相关方法来和数据库服务器来建立连接；然后发送一条或多条SQL语句给服务端从而访问数据库中的数据。

然而上述第二种方式，应用程序会直接调用数据库的方法，这种方法只适合于数据库系统暴露了API的情况。在这种情况下，我们说这个应用程序把一个数据库系统嵌入了其中。

一个嵌入型的数据库的例子如下所示，代码中创建了一个新的事务，调用planner的相关方法来为一个SQL查询创建一个plan对象，获得plan对象后，我们可以调用这个对象的`open()`方法来获得一个scan对象，再迭代这个scan对象，我们可以得到每条具体的数据，最后提交这个事务即可。
```Java
SimpleDB.init("studentdb");
Transaction tx = new Transaction();

Planner planner = SimpleDB.planner();
String qry = "select sname, gradyear from student";
Plan p = planner.createQueryPlan(qry, tx);
Scan s = p.open();

while (s.next())
    System.out.println(s.getString("sname") + " " +
                        s.getInt("gradyear"));

s.close();
tx.commit();
```

相反，一个服务型的数据库的示例代码则如下所示。
```Java
Driver d = new SimpleDriver();
String url = "jdbc:simpledb://localhost";
Connection conn = d.connect(url, null);

Statement stmt = conn.createStatement();
String qry = "select sname, gradyear from student";
ResultSet rs = stmt.executeQuery(qry);

while (rs.next())
    System.out.println(s.getString("sname") + " " +
                        s.getInt("gradyear"));

                        rs.close();
conn.commit();
```
我们可以看到，嵌入型的数据库代码中使用了SimpleDB中的5个类:`SimpleDB`,`Transaction`,`Planner`,`Plan`和`Scan`；而服务型的数据库代码中则使用了接口`Driver`,`Connection`,`Statement`和`ResultSet`。其实这些类和接口是存在着一种如图20-2所示的对应关系的，表中也展示了`ResultSetMetaData`接口和`Schema`类之间的对应关系。

![](ch20/20-2.png)

上图表中的每一行都表示二者之间有一种共同的目的。例如，`Connection`和`Transaction`都是用来管理事务的；而`Statement`和`Planner`,`Plan`都是来处理SQL语句的；而`ResultSet`和`Scan`都是来迭代查询结果的。通过这种对应关系，任何一个JDBC程序都可以被重构成等效的嵌入数据库的程序（当然，我们并不会这么做）。

使用嵌入型的数据库系统的程序不会（也不能）与其他程序共享其数据库。嵌入了数据库的应用程序对数据库是私有的。应用程序中没有其他用户，也没有其他线程（除非程序自己创建线程，如图14-30所示）。实际上，如果两个程序共享同一个嵌入式数据库，则没有什么方法可以阻止数据库损坏——这些程序无法控制对方做出的修改，因为每个程序都管理着自己的`锁表(Lock Table)`。

所以，这种嵌入型的数据库系统只对一些特定的应用有意义，这种系统一般是：
- 无法轻易地连接到数据库服务器，或者；
- 排斥其他用户访问数据(即只希望自己拥有数据)

对应上述第一条的最好的例子就是汽车的GPS导航系统了，一个GPS应用程序会访问数据库中的道路信息和位置信息。对于移动的汽车来说，连接到数据库服务器是很慢并且不稳定的，因此，一个嵌入型的数据库系统才更有可能运行应用程序顺利地操作并且可靠地访问数据。

而对应上述第二条的一个例子就是传感器控制系统，例如核反应堆中的程序。这种系统周期地从多个传感器中得到数据，并且将这些数据保存到数据库中，并进行相应的数据分析。这些传感器数据往往都是与其他的控制系统分离的，因此不需要设计一种服务型的数据库。

使用嵌入型数据库系统的一个后果是，应用程序必须在本地运行数据库代码，运行速度可能比服务型数据库慢得多。然而，嵌入型数据库系统可以进行自定义，从而允许用户关闭不需要的功能。例如，再次考虑GPS导航系统，该系统是只读的，不会运行并发线程，因此，它不需要恢复管理(revovery manager)，并发控制器(concurrency control)或update planner组件。通过从嵌入型数据库中删除这些功能，GPS系统变得更苗条，更快，甚至比在高端计算机上使用功能齐全的共享数据库服务器时还要快。

## 20.2 客户端-服务端通信
我们现在着重考虑如何实现服务型数据库，要实现数据库服务器，必须解决两个问题：
- 客户端和服务端之间怎样通信？
- 怎样实现JDBC接口？

在这个小节中，我们将解决第一个问题；而第二个问题将在20.3小节中讨论。

### 20.2.1 远程方法调用
SimpleDB中通过Java中的远程方法调用(Remote Method Invocation,RMI)来实现C/S间通信。为了使用RMI，系统必须定义一些接口，这些接口继承了JavaRMI中的接口`Remote`，这些接口被称为远程接口(remote interface)。对于每个远程接口，都会对应有两个实现类：客户端上的`存根(stub)`类和服务端上的实现类。放客户端调用一个存根对象的相关方法时，这个方法调用会通过网络传递给服务端，从服务端上的对应的实现类对象会执行相关方法，然后服务端会将执行方法返回的对象送回给客户端上的存根对象。关于更多Java RMI相关的知识，可以去网上查找相关资料，总而言之，一个远程方法是被客户端上的存根对象调用的，而实际是在服务端中的实现类对象完成的。

SimpleDB中定义了5个远程接口，分别是`RemoteDriver`, `RemoteConnection`,`RemoteStatement`, `RemoteResultSet`和`RemoteMetaData`，定义这些接口的代码如下所示。这些远程接口反应的是其对应的JDBC接口，但是有两个区别：
- 只实现了基本的JDBC方法；
- 抛出的异常是RemoteException（这是RMI要求的），而不是抛出SQLException（这是JDBC的要求）
```Java
public interface RemoteDriver extends Remote {
    public RemoteConnection connect() throws RemoteException;
}

public interface RemoteConnection extends Remote {
    public RemoteStatement createStatement() throws RemoteException;
    public void close() throws RemoteException;
}

public interface RemoteStatement extends Remote {
    public RemoteResultSet executeQuery(String qry) throws RemoteException;
    public int executeUpdateCmd(String cmd) throws RemoteException;
}

public interface RemoteResultSet extends Remote {
    public boolean next() throws RemoteException;
    public int getInt(String fieldName) throws RemoteException;
    public String getString(String fieldName) throws RemoteException;
    public RemoteMetaData getMetaData() throws RemoteException;
    public void close() throws RemoteException;
}

public interface RemoteMetaData extends Remote {
    public int getColumnCount() throws RemoteException;
    public  String getColumnName(int column) throws RemoteException;
    public int getColumnType(int column) throws RemoteException;
    public int getColumnDisplaySize(int column) throws RemoteException;
}
```
为了对RMI是如果工作的有个大概的了解，请考虑下面这样一段客户端的代码片段:
```Java
RemoteDriver rdvr = ...
RemoteConnection rconn = rdvr.connect();
RemoteStatement rstmt = rconn.createStatement();
```
上述代码片段中的每个变量都表示一个接口。但是，由于代码片段是运行在客户端上的，因此我们知道这些变量持有的实际对象来自存根类。请注意，该代码片段中未显示变量`rdvr`是如何获得其存根的。我们在这里先暂时搁置一下这个问题，直到后续讨论RMI注册时，我们再来讨论这个问题。

我们考虑一下`rdvr.connect()`这条语句，存根通过将请求经过网络发送到服务器上相应的RemoteDriver实现对象来实现此方法。远程实现类对象会在服务器端执行它自己的`connect()`方法，相应地，执行`connect()`方法会返回一个新的`RemoteConnection`实现类对象，而此远程对象的存根则被发送回客户端，客户端将其存储为变量`conn`的值。

再考虑一下`rconn.createStatement()`这条语句。存根对象会将请求发送给服务器上与该存根对象对应的`RemoteConnection`实现对象。该远程对象执行其`createStatement()`方法,并在服务器上创建一个·RemoteStatement·实现对象，并再次将其存根返回给客户端。

### 20.2.2 RMI注册
