# 第15 章



## 15.2 实现保存记录的文件
现在我们已经知道了记录管理器必须解决的一些问题，以及相应可选的策略。现在我们来决定一下具体怎么实现，我们从最简单直接的实现开始讨论：即文件中的记录是同类的，非跨块的，并且是固定长度的。我们随后考虑其他的一些实现。

### 15.2.1 最直接的实现
假设我们现在想要创建一个同类的，非跨块的，并且长度固定的记录。非跨块也就是是说我吗可以把文件看做是一系列的文件块，其中每个块上都包含了每个块自己的记录；此外记录是同类的并且长度固定的特点意味着我们可以在每个块中开辟相同数量的数据记录，也就是说，我们可以把每个块看成是一个包含许多记录的数组，我们称这样的块在内存中对应的页为一个`记录页(record page)`。
> 一个记录页指的是包含定长记录数组的页。

记录管理器可以这样来实现记录页。先将整个页分为很多的`槽(slots)`，其中每个槽中含有一条记录和一个额外的字节，这个额外的字节是一个标志位，用来表示这个槽是空的还是在被使用，我们假设0代表空的，1代表在使用（其实我们可以用一个bit来设置标志位，详细请看练习15.8）。

举例来说，假设块的大小是400字节，并且一条记录的大小的26字节；于是每个槽的大小就是27字节，于是每个块可以容纳14个槽，伴随着22字节的浪费空间，图15-5展示了这个场景，图中只展示了4个槽，其中第0个槽和第13个槽当前已经包含有记录，而槽1和槽2是空的。

![](ch15/15-5.png)

记录管理器需要可以插入、删除、修改一个记录页中的记录，为了完成这些功能，记录管理器会用到下面的信息：
- 一条记录的长度
- 一条记录中各个字段的名称、类型、长度和偏移量

我们把这些值称为`表信息(table information)`。

例如，考虑一下STUDENT这个表，其定义和第2章中一样。一个学生记录包含3个整数和一个10字节的varchar字段。如果我们使用SimpleDB中的存储策略，那么每个整数需要4个字节，一个长度为10字符的字符串需要14个字节(译者注：中文字符另当别论，在我的机器中，每个中文需要3个字节来维护)。并且我们假设不需要padding，且varchar字段的实现策略是，开辟可能最长字符串的空间，从而长度是固定的。于是图15-6给出了这个学生表的表信息，注意，`SName`字段的长度该字段存储需要的字节数，而不是这个字段的最大字符数。

![](ch15/15-6.png)

这个表信息将允许记录管理器来决定这个记录中哪个地方有什么值，例如：
- 第k个槽的空/使用中标志位的位置是`(RL+1)*K`,其中RL是一条记录的长度。
- 第k条记录中字段F的位置是`(RL+1)*K + 1 + OFF`,其中RL是一条记录的长度，而OFF是字段F在一条记录中的偏移量。

记录管理器因此可以很简答地完成插入、删除和修改记录的过程：
- 为了插入一个记录，记录管理器需要先检查一下记录页中的所有标志位，直到找到第一个0；随后将这个标志位设置为1，并且返回该槽的槽号。如果所有的槽当前的标志位都是1，也就是说当前块是满的，无法插入新的记录。
- 为了删除第k个槽中的记录，记录管理器只需要简单第将该槽的标志位设置为0，其他的什么都不用干。
- 为了修改第k个槽中的记录的某个字段（或者是初始化一个新的记录中的某个字段），记录管理器会先判断一下这个字段的位置，然后在那个位置写入相应的值。

记录管理器也可以很简单第执行检索记录的操作：
- 为了遍历一个块上的所有记录，记录管理器只需要先查看每个槽的标志位，每次标志位是1，记录管理器就知道这个槽是包含记录的。
- 为了检索第k个槽上的记录的某个字段的值，记录管理器先判断一下每个字段的位置，然后从相应的位置读出字段的具体值即可。

正如上面所述的操作一样，记录管理器需要一种方法来识别每一条记录。当记录是定长的时候，最简单直接的记录标识符就是它对应的槽号。
> 记录页中的每个记录都有一个ID，当记录是定长时，ID可以是槽号。

### 15.2.2 实现变长字段
定长字段的实现非常简单，在本小节中，我们将考虑一下如果加入了变长的字段，那么记录的实现会有怎样的变化。

我们首先会发现的问题就是一个记录中每个字段的偏移量将不再固定。特别地，含有变长字段的记录，记录中每个字段的偏移量可能都是随记录的不同而不同的。判断字段偏移量的唯一办法就是读出前一个字段，然后看下前面的字段在哪里技术的。如果记录中的第1个字段是变长字段，那么为了读第$$n$$个字段，我们必须先读前$$n-1$$个字段。因此，记录管理器通常会把那些定长字段防止在每条记录的开头，以便于可以尽可能多地直接根据偏移量来读取字段的值；而那些变长的字段被放置在记录的后边儿，这样一来，前面的字段会有确定的偏移量，而后面的那些变长字段就没有固定的偏移量 了。

其实，我们也会注意到这样一个问题，每个记录的长度也因此会变得不同，这样会带来两个很重要的结果：
- 通过用槽号乘上槽长度的方式来定位块中具体某个记录的方法将不再可能。现在，为了读取到某条记录的开始位置，我们必须获取到它上一条位置的结束位置。
- 修改某个字段的值将可能使得整个记录的长度都变化。在这种情况下，块中所有那些原来在修改的字段右边的字节全部要右移，更糟糕的是，如果修改后的字段值很长，那么这个修改后记录加上原来的记录长度总和可能会顶出整个块的长度，这种情况必须通过开辟一个`溢出块(overflow block)`来解决。

一个溢出块指的是从`溢出区(overflow area)`申请的新块。那些顶出到块外面的记录都将被放在溢出块中。如果我们非常不幸于，一个客户端修改了很多记录中的很多变长字段的值，并且修改后的值都是很长很长的，那么就有可能很多记录都要被放到溢出块中去，所以，很可能我们需要多个溢出块来hold它们，于是，溢出块就可能是一个链式的结构。每个块（包括原始块）都会有一个指向下一个溢出块的引用，那么从概念上来说，原始块加上所有的溢出块才构成了我们所有的记录。

例如，考虑一下COURSE表，并且假设这个表中的title字段是以变成字符串形式存储的，图15-7（a）展示了这个表中当前包含的3条记录（其中title字段被放在了记录的结尾，因为其他字段都是定长的），图15-7（b）展示了将“DBSy”修改成“Database System Implementation”后的情况，假设一个块的大小是80字节，那么低3个记录将在这个块中装不下，于是它被放在了一个溢出块中，原始块会有一个指向溢出块的引用。

除了需要溢出块这个“缺点”，定长字段引入的复杂性其实并不会对整个系统的效率产生什么影响，当然，记录管理器现在需要做更多的事情：它需要每次在修改了某个字段的值后移动其他的记录，并且为了读取某个记录它必须读取前面的记录。然而，这些操作实际上不会引入额外的块引用，因此不是很耗时，但是，的确有一种常用的改进策略。

考虑一个删除记录的操作，在图15-8（a）展示了一个包含3个课程记录的块，和图15-7（a）中一样。现在，删除第22号课程记录，我们需要将标志位置为0，但是让记录中的数据原封不动地保留在那，如图15-8（b）所示的那样。由于新的记录不一定适合该记录所留下的空白空间，因此我们想通过从记录块中物理移除该记录，并将记录后面的那些记录左移。 但是，这里存在一个问题：记录管理器使用记录的槽号作为其ID，因此消除已删除的记录将导致块中的后续记录具有错误的ID。

该问题的解决办法是把记录的ID和槽号不再关联，也就是说，我们将一系列的整型数组到块中，称之为`ID表(ID-table)`。数组中的每个entry表示的是一个ID，每个entry的值表示的是该ID对应的记录的起始地址；如果没有该记录，则这个entry的值为0，图15-8（c）展示了和图15-8（b）中相同的数据情况，但是用了ID表。当前ID表中包含3个entry，其中两个分别指向第43字节起始和第63字节起始的记录，另外一个记录是空的。

ID表提供了一个间接的方式，指导记录管理器如何在块内部移动记。 如果记录移动，则相应地调整其在ID表中的entry； 如果将记录删除，则将其entry设置为0。插入新记录时，记录管理器在ID表中找到可用的entry并将其分配为新记录的ID。
> ID表的存在，允许变长记录在一个块内移动，同时给每个记录都提供了一个定长的标识符。

注意，ID表会随着块中记录数的增加而扩张，ID表的数组大小因此必须是开放的，因为一个块可以装下的变长记录数是不定的。通常，ID表被放在块的一端，而那些记录被放在另一端，它们都各自朝着对方增长，这个情形可以在图15-8（c）中观察到，其中第一个记录在最右边。

此外也请注意一下ID表，现在就没必要设置空/使用中的标志位，如果一个记录存在，那么在ID表中必定存在一个指向该记录起始地址的entry，而空的记录肯定是有一个值为0的enrty（实际上不存在）。ID表同样也帮助记录管理器很快地找到下一个记录。为了移动到一个给定ID的记录，记录管理器只需很简单地使用ID表中存储着的偏移量；而移动至下一条记录，记录管理器只需要往下访问ID表，直到它找到下一个非0的entry。

### 15.2.3 实现跨块的记录
我们接下来考虑一下为了实现跨块的记录，我们要做出那些变化。

当记录不是跨块的时候，一个块中的第一条记录总是会在相同的位置开始（例如，从第0号字节开始）。而在跨块的时候，情况就不是这样了。于是记录管理器必须在每个块中存储一些信息，用来判断记录在哪里。

这里有好几种可能的实现策略：
- 第一种策略就是让记录管理器在每个块的开始存一个整数，这个整数表示的是==块中第一条记录的偏移量==。例如，考虑一下图15-9（a）中的情况，block 0的第一个整数是4，表示第一条记录的起始位置是4（也就是说，紧接着该整数就是第一条记录的起始位置），记录R2跨越了block 0和block 1，因此block 1中的第一条记录是R3，其起始位置是60。记录R3也是跨块的，跨越了block 1、block 2和block 3，因此记录R4是block 3中的第一条记录，偏移量为30.注意，block 2的第一个整数是0，表示在该块中没有记录在该块中开头。
- 第二种策略也是在每个块的开始存一个整数，但是这个整数的意思不太一样，即，这个整数表示的是==最开始的数据对应于该记录的第多少个字节==。如果第一条记录是非跨块的，那么这个整数就是0（即从这条记录的第0个字节开始），否则，这个整数将会是该记录在前面块中的字节数。例如，考虑图15-9（b）中的情况，block 0中的值0表示的是记录R1是非跨块的，而block 1中的值24表示的意思是记录R2的前24个字节都在前面的块中，也就是说该块的第1个字节将是这条记录的第25个字节，而block 3中的值436表示的是记录R3的前436个字节都在前序块中（注意，前序块可能不知一个块，可能是多个块）。在这里，我们假设每个块的大小是400字节，由于记录管理器知道块的大小，于是它可以计算出当前记录是由几个块来装的。

除了上述的实现方案，记录管理器还可以选择以不同的方式来分割一个跨块的记录。
- 第一种方法就是尽可能地填充块，一旦到了块的边界，那就把记录分割开来，剩下的字节就装在文件的下一个块中。
- 第二种方法就是value-by-value地将记录保存在块中，当一个value写不下时，就把这个value写在下一个块中，因此，会有很少很少的字节变得浪费。

第一种方法的有点就是完全没有一点儿浪费空间，但是缺点就是可能将一个value的值分布在两个块中（比如，一个int的前3个字节在block 1中，而第4个字节在block 2上），这样会给我们到时候读取值又带来一定困难，记录管理器必须把这些分散的字节给concat起来。

### 15.2.4  实现非同类记录
假如记录管理器支持非同类记录，那么它也将需要支持变长记录，因为不同表中的不同记录不一定非要是相同长度的，也肯定不能规定是相同长度的。

在块中保存非同类记录将会带来两个相关的问题：
- 记录管理器需要知道块中每种记录的表信息。
- 给定一条记录，记录管理器需要知道它来自哪一个表。

记录管理器可以通过保存一个表信息数组来解决第一个问题，数组中的每个item都是一个表信息；记录管理器可以通过给每个槽添加一个额外的值来解决第二个问题，这个额外的值有时候被称为一个`标签值(tag value)`，改值就是表信息数组的索引，指示了这条记录属于哪个表。

![](ch15/15-2.png)

例如，再次考虑一下图15-2中的例子，该图展示的是一个非同类块的例子，其中的记录来自DEPT表和STUDENT表。记录管理器将会维护一个数组，来保存每个表的表信息，让我们假设DEPT表在数组的第0个item，STUDENT表在第1个item。于是每条DEPT记录对应的槽将有一个标签值0，每条STUDENT记录对应的槽将有一个标签值1。

记录管理器不需要改变太多的行为，当记录管理器访问一条记录时，它会从标签值来判断使用哪一个表信息。它然后可以使用该表信息来读/写任意字段，和在同类文件中的操作一样。
