# 第14章 事务管理和包`simpledb.tx`

缓冲管理器允许多个客户端同时访问同一缓冲区，从中任意读取和写入值。这样的造成结果可能是混乱的：每次客户端查看页面时，页面可能具有不同（甚至不一致）的值，从而使客户端无法获得准确的数据库视图。或两个客户端可以在不经意间覆盖彼此的值，从而破坏数据库。

在本章中，我们将学习`恢复管理器（recovery manager）`和`并发管理器（concurrency manager）`,它们的任务是为何数据库的秩序和数据的一致性。每个客户端程序都按照一系列事务而组织，并发管理器调节这些事务的执行以使得它们的行为保持一致。恢复管理器从日志文件中读/写日志记录，以便于在必要的适合，可以`撤销(undo)`未提交事务所作出的更改。本章介绍了这两个管理器的功能以及实现它们的技术。

## 14.1 事务
### 14.1.1 正确的代码执行结果却不正确
考虑一个航班预定数据库，有2个数据库表，它们的schema如下：
```
SEATS(FlightId, NumAvailable, Price)

Cust(CustId, BalanceDue)
```

下面的代码包含了为指定的客户购买一张指定航班机票的JDBC代码、虽然代码本身没有bug，但是当多个客户端并发执行或者服务器崩溃的时候，很多问题都有可能产生。
```Java
public void reserveSeat(Connection conn, int custId, int flightId) throws SQLException{

    Statement stmt= conn.createStatement();
    String s;
    
    // 步骤1：获取剩余票数和价格
    s="SELECT NumAvailable, Price FROM SEATS "+
        " WHERE FlightId= "+flightId;
    ResultSet rs= stmt.executeQuery(s);
    if(!rs.next()){
        System.out.println("Flight doesn't exist!");
        return;
    }
    int numAvailable = rs.getInt("NumAvailable");
    int price = rs.getInt("Price");
    rs.close();
    
    if(numAvailable==0){
        System.out.println("Flight is full!");
        return;
    }
    
    // 步骤2：更新剩余票数
    int newNumAvailable = numAvailable - 1;
    s="UPDATE SEATS set NumAvailable =" +newNumAvailable+
        " WHERE FlightId= "+flightId;
    stmt.executeUpdate(s);
    
    // 步骤3：获取并更新用欠款
    s="SELECT BalanceDue FROM CUST " +
        " WHERE CustId= "+custId;
    rs=stmt.executeQuery(s);
    int newBalance = rs.getInt("BalanceDue")+ price;
    rs.close();
    
    s="UPDATE CUST set BalanceDue =" +newBalance+
        " WHERE CustId= "+custId;
    stmt.executeUpdate(s);
}
```

下述的3个场景示例了这些问题。

①第一个场景，假设两个客户端A、B都并发地运行上述JDBC代码，具体的执行序列如下所示：
- 客户端A执行完步骤1的所有步骤后被打断
- 客户端B执行，直到完成
- 客户端A完成剩余操作

在这个例子中，两个线程都会使用相同的变量值`numAvailable`,这样一来的结果是，两个座位都会被卖出，但是数据库中的剩余座位数只会被减少1次。

②第二个场景，假设线程C正在运行代码，然后再执行完步骤2后，系统崩溃了。在这种情况下，座位将被预定，但是顾客不会被收钱。

③第三个场景，假设一个客户端执行代码直到完成，但是被修改的页没有立即被写回磁盘因为缓冲的原因。假如服务器崩溃了，然后就再也没有办法知道哪个页最终需要写回到磁盘。如果上述代码中的第一次更新写回了磁盘（即剩余机票数），却第二次没有（即更新用户欠费），那么顾客得到了一张免费机票；如果第二次更新写回到了磁盘，第一次却没有，那么客户为一张根本系统中不存在的机票记录买了单；假如两次更新都没写回磁盘，这个情况到还好，就是整个交互记录丢失了，系统根本感受不到用户曾经买过票。

### 14.1.2 事务的属性
在上述的场景说明，如果客户端代码随意运行，那么数据就可能丢掉或损坏。数据库系统通过强制客户端程序包含事务来解决这些问题。

> 事务是一组操作，它们的行为被看做一整个操作来看待。一个事务必须满足`ACID`属性。

“一整个操作”的可以被概括为所谓的ACID属性：`原子性(Atomicity)`,`一直性(Consistency)`,`独立性(Isolation)`和`持久性(Durability)`。
- 原子性的意思是，一个事务要么做完，要么就不做。也就是说，要么事务中的所有操作都执行成功（事务commit了），要么事务执行失败（事务rollback了）
- 一致性的意思是，每个事务都会使得数据库系统处于一个一致性的状态。这意味着每个事务都是可以执行的完整工作单元，且独立于其他事务。
- 独立性的意思是，一个事务的行为在自己看来，就好像整个数据库只在执行当前这个事务。也就是说，如果多个事务并发执行，它们的结果应该和这些事务顺序执行的结果一样，不会因为并发而相互影响。
- 持久性的意思是，提交了的事务修改必须保证持久化到磁盘上。

14.1.1小节中示例的每一个问题都或多或少地违反了上述ACID原则。第一个场景违反了独立性原则，因为每个客户端都读到了相同的`numAvailable`变量值，然而顺序执行两个客户端的代码将导致第二个执行的客户端读到第一个用户修改后的数据；第二个场景违反了原子原子；第三个场景违反了持久化原则。
> 原子性和持久性描述了commit操作和rollback操作的正确行为。

特别是，已提交的事务必须是持久的，而未提交的事务（由于显式回滚或系统崩溃）必须完全撤消其更改。这些功能是恢复管理器的责任，那是14.3节的主题。
> 一致性和独立性描述了客户端并发操作的正确行为。

特别是，数据库服务器必须放置客户端之前发生冲突，一个典型策略的就是检测何时冲突可能发生，然后让一个客户端等待，直到冲突不再可能发生为止。这些功能都是并发管理器的职责，是14.4节的主题。

## 14.2 在SimpleDB中使用事务
在我们深入到恢复管理器和并发管理器的细节之前，对客户端如何使用事务有个初步的了解，会帮助我们更好地理解。在SimpleDB中，每个JDBC事务都有一个`Transaction`对象，它的API如下所示：
```Java
public class Transaction {

    public Transaction();
    public void commit();
    public void rollback();
    public void recover();

    public void pin(Block blk);
    public void unpin(Block blk);
    public int getInt(Block blk,int offset);
    public String getString(Block blk,int offset);
    public void setInt(Block blk,int offset,int val);
    public void setString(Block blk,int offset,String val);

    public int size(String fileName);
    public Block append(String fileName, PageFormatter pfmt);

}
```
`Transaction`类的方法被分为3大类别，第一类包含了事务生命周期的方法，构造函数开始一个新事务，`commit()`和`rollback()`方法结束一个事务，`recover()`方法会为所有没提交的事务执行回滚方法。

第二类包含了访问磁盘块的方法，这些方法和缓冲管理器中的方法很类似，但一个重要的区别就是，一个事务会将中间存在的缓冲区向客户端隐藏掉，并且不会返回给客户端缓冲区。当客户端执行`getInt()`方法时，传入的是一个块的引用，事务会相应地寻找缓冲区，调用缓冲区的getInt()`方法，然后把结果传递回客户端。事务把缓冲区的细节向客户端隐藏掉，因此可以对并发管理器和恢复管理器进行必要的调用。例如，`setInt()`方法代码会获得适当的锁（并发控制锁），然后会在修改缓冲区之前，将缓冲区中当前的值写入日志文件（用于恢复）。

第三类包含了和文件管理器相关的两个方法。方法`size()`会读取文件的末尾，方法`append()`会修改它；这些方法会被并发管理器调用从而避免潜在的冲突。

下面的代码片段演示了对事务类的简单实用：
```Java
public class TransactionTest {

    public static void main(String[] args) {
        SimpleDB.init("studentdb");
        Transaction tx = new Transaction();
        Block blk = new Block("junk", 3);
        tx.pin(blk);
        int n = tx.getInt(blk, 392);
        String str = tx.getString(blk, 20);
        tx.unpin(blk);
        System.out.println("Values are " + n + " and " + str);

        tx.pin(blk);
        n = tx.getInt(blk, 392); // 这条语句必要吗？？？
        tx.setInt(blk, 392, n + 1);
        tx.unpin(blk);

        PageFormatter pfmt = new ABCStringFormatter();
        Block newBlk = tx.append("junk", pfmt);
        tx.pin(newBlk);
        String s = tx.getString(newBlk, 0);
        assert (s.equals("abc"));
        tx.unpin(newBlk);
        int newBlkNum = newBlk.number();
        System.out.println("The first string in block "
                + newBlkNum + " is" + newBlkNum);
        
        tx.commit();
    }
}
```
该代码由三部分组成，它们和第13章的测试用例执行相同的任务。第一部分将文件`junk`的block 3固定，并从中读取两个值：偏移量为392的整数和偏移量为20的字符串。第二部分把该块的偏移量392处的整数自增1。第三部分则格式化一个新页，将其附加到文件`junk`中，并读取存储在偏移量0中的值；最后，事务提交。

这个示例代码比第13章中对应的示例代码更简洁一些，主要是因为事务对象会负责管理缓冲和日志，其实同样重要的是，事务对象也会管理并发客户端相关的问题。

例如，观察代码我们可以发现，第一部分和第二部分都对`getInt()`方法进行了的调用，我们需要调用两次吗？第二次调用是否总是返回与第一次调用完全相同的值？在没有并发控制的情况下，答案是“否”。假定此代码在执行第一次调用之后，但又在执行第二次调用之前被中断，并且另一个客户端在此中断期间执行并修改了偏移量392的值。然后，第二个调用实际上将返回与第一个调用不同的东西。（这是第8.2.3节中提到的“不可重复读取”）此方案违反了事务的独立性原则，因此Transaction对象需要对此负责，并确保这种情况不会发生。换句话说，由于并发控制的存在，我们的确不需要第二次调用`getInt()`。

## 14.3 恢复管理器
恢复管理器是数据库服务端负责读取并且处理日志信息的部分。它主要有三大功能：`写日志记录`、`回滚事务`和`数据库系统崩溃后恢复`。这一节中我们将研究这些功能的细节。

### 14.3.1 日志记录
为了能够回滚事务，恢复管理器将有关事务活动的信息保存在日志中。特别是，在每次发生一个loggable的事件时，它会将一条相关的`日志记录(log record)`写入日志文件中。日志记录有四种基本类型：`开始日志记录（start log record）`，`提交日志记录（commit log record）`，`回滚日志记录（rollback log record）`和`更新日志记录（update log record）`。我们将遵循SimpleDB中的设定并假设有两种更新日志记录：一种用于更新整数，另一种用于更新字符串。

> 三种可以引发日志记录写入的事件为：
- 事务开始时的开始日志记录
- 事务完成时的提交日志记录或回滚日志记录
- 当事务修改某个值时的修改日志记录

另一个潜在的loggable的事件是在文件末尾附加一个块。然后，如果事务回滚，则可以从文件中释放由`append()`方法分配的新块。另一方面，让新块保留在那不做任何修改也不会有任何危害，因为它不会影响其他的事务。为了简单起见，我们将忽略追加`日志记录(log append record)`的可能性。 练习14.48解决了这个问题

作为示例，再次考虑上述使用事务的代码片段，该片段在文件`junk`的block3,偏移量为392处的整数进行了自增1。假设事务的ID为27，并且该偏移处的旧值为整数542。下面的序列中包含了从此代码生成的日志记录：
```
<START, 27>
<SETINT, 27, junk, 3, 392, 542, 543>
<COMMIT, 27>
```
请注意，每条日志记录都包含有关该记录的类型描述（START，SETINT，SETSTRING，COMMIT或ROLLBACK）及其事务的ID。更新日志记录包含五项其他内容：修改的文件名、块号、进行修改的位置的偏移量、该偏移量处的旧值，以及该偏移量处的新值。

通常，多个事务将并发地写入日志，因此给定事务的日志记录将被分散在整个日志中。

### 14.3.2 回滚
日志的一个作用是帮助恢复管理器`回滚（roll back）`一个指定的事务。
> 恢复管理器通过撤销修改来回滚一个事务。

由于这些修改已列在更新日志记录中，因此扫描日志，查找每个更新记录并将每个修改后值恢复到原始内容是相对简单的事情。算法14-5给出了该算法的描述。

```
Algorithm 14-5 事务T的回滚算法

1. 把最近的日志记录作为当前日志记录;
2. while(当前日志记录 != 事务T的开始日志记录){
        if(当前日志记录 == 事务T的更新日志记录)
            在指定位置写入修改前的old value;
        else
           当前日志记录 = 上一条日志记录; 
    }
3. 追加一条回滚日志记录到日志文件;
```
为什么此算法从日志文件末尾开始向前读取，而不是从开始位置向后读取？有两个原因：第一个原因是日志文件的开头将包含来长期完成的事务的日志记录，我们正在寻找的日志记录最有可能在日志的末尾，因此从末尾读取效率更高；第二个更重要的原因是要确保正确性。假设某个位置的值被修改多次，然后日志文件中将有对应该位置的多个日志记录，每个都有不同的值。 要恢复的值应该来自这些日志记录中最早的一个，如果以相反的顺序处理日志记录，则实际上会发生这种情况。

### 14.3.3 恢复